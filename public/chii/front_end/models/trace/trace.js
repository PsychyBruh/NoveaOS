import*as e from"../../core/platform/platform.js";import*as t from"./helpers/helpers.js";export{t as Helpers};import*as s from"./types/types.js";export{s as Types};import*as n from"./extras/extras.js";export{n as Extras};import*as r from"./handlers/handlers.js";export{r as Handlers};import*as a from"../../core/common/common.js";import*as i from"./root-causes/root-causes.js";export{i as RootCauses};import*as o from"../../core/sdk/sdk.js";const c=new Set(["MERGE_FUNCTION","COLLAPSE_FUNCTION","COLLAPSE_REPEATING_DESCENDANTS"]),l=new Set(["RESET_CHILDREN","UNDO_ALL_ACTIONS"]);var d=Object.freeze({__proto__:null,EntriesFilter:class{#e;#t=[];#s=[];#n=new Map;constructor(e){this.#e=e}applyAction(e){this.#r(e)?this.#a(e):this.#i(e.type)&&this.#o(e)}#o(e){switch(e.type){case"UNDO_ALL_ACTIONS":this.#t=[],this.#s=[];break;case"RESET_CHILDREN":this.#c(e.entry)}}invisibleEntries(){return this.#t}#a(t){this.#s.push(t.entry);const s=new Set;switch(t.type){case"MERGE_FUNCTION":s.add(t.entry);break;case"COLLAPSE_FUNCTION":{const e=this.#e.get(t.entry);if(!e)break;this.#l(e).forEach((e=>s.add(e)));break}case"COLLAPSE_REPEATING_DESCENDANTS":{const e=this.#e.get(t.entry);if(!e)break;this.#d(e).forEach((e=>s.add(e)));break}default:e.assertNever(t.type,`Unknown EntriesFilter action: ${t.type}`)}return this.#t.push(...s),this.#t}#l(e){const t=this.#n.get(e);if(t)return t;const s=[],n=[...e.children];for(;n.length>0;){const e=n.shift();if(e){s.push(e.entry);const t=this.#n.get(e);t?s.push(...t):n.push(...e.children)}}return this.#n.set(e,s),s}#d(e){const n=[...e.children],r=[],a=s.TraceEvents.isProfileCall(e.entry);for(;n.length>0;){const i=n.shift();if(i){const o=s.TraceEvents.isProfileCall(i.entry);if(a&&o){const s=e.entry,n=i.entry;t.SamplesIntegrator.SamplesIntegrator.framesAreEqual(s.callFrame,n.callFrame)&&r.push(i.entry)}else a||o||e.entry.name===i.entry.name&&r.push(i.entry);n.push(...i.children)}}return r}#c(e){const t=this.#e.get(e);if(!t)return;const s=this.#l(t);this.#t=this.#t.filter((e=>!s.includes(e))),this.#s=this.#s.filter((t=>!s.includes(t)&&t!==e))}isEntryModified(e){return this.#s.includes(e)}#r(e){return c.has(e.type)}#i(e){return l.has(e)}}});class h{#h;#p;#m;#u;#v;#f;#g;#E;#y;#T;#I;#C=[];constructor(e){this.#h=e,this.#p=new Map,this.#m=new Map,this.#u=Number(1/0),this.#v=Number(-1/0),this.#f=[],this.#g=[],this.#E=new Map,this.#y=new Map,this.#T=new Map,this.#I=new Map}static isTopLevelEvent(e){return N(e,f)&&"RunTask"===e.name||N(e,u)||N(e,v)&&"Program"===e.name}static extractId(e){const t=e.scope||"";if(void 0===e.id2)return t&&e.id?`${t}@${e.id}`:e.id;const s=e.id2;if("object"==typeof s&&"global"in s!="local"in s)return void 0!==s.global?`:${t}:${s.global}`:`:${t}:${e.pid}:${s.local}`;console.error(`Unexpected id2 field at ${e.ts/1e3}, one and only one of 'local' and 'global' should be present.`)}static browserMainThread(e){const t=e.sortedProcesses();if(!t.length)return null;const s="CrBrowserMain",n=[],r=[];for(const e of t)e.name().toLowerCase().endsWith("browser")&&n.push(e),r.push(...e.sortedThreads().filter((e=>e.name()===s)));if(1===r.length)return r[0];if(1===n.length)return n[0].threadByName(s);const i=e.devToolsMetadataEvents().filter((e=>"TracingStartedInBrowser"===e.name));return 1===i.length?i[0].thread:(a.Console.Console.instance().error("Failed to find browser main thread in trace, some timeline features may be unavailable"),null)}allRawEvents(){return this.#C}devToolsMetadataEvents(){return this.#f}addEvents(e){for(let t=0;t<e.length;++t)this.addEvent(e[t])}tracingComplete(){this.processPendingAsyncEvents();for(const e of this.#p.values())for(const t of e.threads.values())t.tracingComplete()}addEvent(e){this.#C.push(e);let t=this.#p.get(e.pid);t||(t=new A(this,e.pid),this.#p.set(e.pid,t));const n=e.ts/1e3;if(n&&n<this.#u&&p.has(e.ph)&&!e.name.endsWith("::UMA")&&(this.#u=n),"TracingStartedInBrowser"===e.name&&(this.#u=n),p.has(e.ph)){const t=(e.ts+(e.dur||0))/1e3;this.#v=Math.max(this.#v,t)}const r=t.addEvent(e);if(r)if("P"!==e.ph){if(s.TraceEvents.isAsyncPhase(e.ph)&&this.#g.push(r),r.hasCategory(v)&&this.#f.push(r),"M"===e.ph)switch(e.name){case m.ProcessSortIndex:t.setSortIndex(e.args.sort_index);break;case m.ProcessName:{const s=e.args.name;t.setName(s),this.#m.set(s,t);break}case m.ThreadSortIndex:t.threadById(e.tid).setSortIndex(e.args.sort_index);break;case m.ThreadName:t.threadById(e.tid).setName(e.args.name)}}else this.addSampleEvent(r)}addSampleEvent(e){const t=`${e.thread.process().id()}:${e.id}`,s=this.#T.get(t);s?s.addChild(e):this.#T.set(t,new C(e))}profileGroup(e){return this.#T.get(`${e.thread.process().id()}:${e.id}`)||null}minimumRecordTime(){return this.#u}maximumRecordTime(){return this.#v}sortedProcesses(){return b.sort([...this.#p.values()])}getProcessByName(e){return this.#m.get(e)??null}getProcessById(e){return this.#p.get(e)||null}getThreadByName(e,t){const s=this.getProcessByName(e);return s&&s.threadByName(t)}processPendingAsyncEvents(){this.#g.sort(g.compareStartTime);for(let e=0;e<this.#g.length;++e){const t=this.#g[e];s.TraceEvents.isNestableAsyncPhase(t.phase)?this.addNestableAsyncEvent(t):this.addAsyncEvent(t)}this.#g=[],this.closeOpenAsyncEvents()}closeOpenAsyncEvents(){for(const e of this.#E.values())e.setEndTime(this.#v),e.steps[0].setEndTime(this.#v);this.#E.clear();for(const e of this.#y.values())for(;e.length;){const t=e.pop();t&&t.setEndTime(this.#v)}this.#y.clear()}addNestableAsyncEvent(e){const t=e.categoriesString+"."+e.id;let s=this.#y.get(t);switch(e.phase){case"b":{s||(s=[],this.#y.set(t,s));const n=new I(e);s.push(n),e.thread.addAsyncEvent(n);break}case"n":if(s&&s.length){const e=s[s.length-1];e&&e.addStep(e)}break;case"e":{if(!s||!s.length)break;const n=s.pop();if(!n)break;if(n.name!==e.name){console.error(`Begin/end event mismatch for nestable async event, ${n.name} vs. ${e.name}, key: ${t}`);break}n.addStep(e)}}}addAsyncEvent(e){const t=e.categoriesString+"."+e.name+"."+e.id;let s=this.#E.get(t);if("S"===e.phase)return s?void console.error(`Event ${e.name} has already been started`):(s=new I(e),this.#E.set(t,s),void e.thread.addAsyncEvent(s));if(s){if("F"===e.phase)return s.addStep(e),void this.#E.delete(t);if("T"===e.phase||"p"===e.phase){const t=s.steps[s.steps.length-1];return t&&"S"!==t.phase&&t.phase!==e.phase?void console.assert(!1,"Async event step phase mismatch: "+t.phase+" at "+t.startTime+" vs. "+e.phase+" at "+e.startTime):void s.addStep(e)}console.assert(!1,"Invalid async event phase")}}title(){return this.#h}parsedCategoriesForString(e){let t=this.#I.get(e);return t||(t=new Set(e?e.split(","):[]),this.#I.set(e,t)),t}}const p=new Set(["B","E","X","I"]),m={ProcessSortIndex:"process_sort_index",ProcessName:"process_name",ThreadSortIndex:"thread_sort_index",ThreadName:"thread_name"},u="toplevel",v="disabled-by-default-devtools.timeline",f="disabled-by-default-devtools.timeline";class g{categoriesString;#I;name;phase;startTime;thread;args;id;ordinal;selfTime;endTime;duration;constructor(e,t,s,n,r){this.categoriesString=e||"",this.#I=r.getModel().parsedCategoriesForString(this.categoriesString),this.name=t,this.phase=s,this.startTime=n,this.thread=r,this.args={},this.ordinal=0,this.selfTime=0}static compareStartTime(e,t){return e&&t?e.startTime-t.startTime:0}static orderedCompareStartTime(e,t){return e.startTime-t.startTime||e.ordinal-t.ordinal||-1}hasCategory(e){return this.#I.has(e)}setEndTime(e){e<this.startTime?console.assert(!1,"Event out of order: "+this.name):(this.endTime=e,this.duration=e-this.startTime)}addArgs(e){for(const t in e)t in this.args&&console.error("Same argument name ("+t+") is used for begin and end phases of "+this.name),this.args[t]=e[t]}complete(e){e.args?this.addArgs(e.args):console.error("Missing mandatory event argument 'args' at "+e.startTime),this.setEndTime(e.startTime)}}class E extends g{constructor(e,t,s,n,r){super(e,t,s,n,r)}}class y extends g{#b;rawLegacyPayload(){return this.#b}rawPayload(){return this.#b}constructor(e,t,s,n,r,a){super(e,t,s,n,r),this.#b=a}static fromPayload(e,t){const s=new y(e.cat,e.name,e.ph,e.ts/1e3,t,e);s.#b=e,e.args&&s.addArgs(e.args),"number"==typeof e.dur&&s.setEndTime((e.ts+e.dur)/1e3);const n=h.extractId(e);return void 0!==n&&(s.id=n),s}}class T extends y{constructor(e,t,s,n,r){super(e,t,"O",s,n,r)}static fromPayload(e,t){const s=new T(e.cat,e.name,e.ts/1e3,t,e),n=h.extractId(e);return void 0!==n&&(s.id=n),e.args&&e.args.snapshot?(e.args&&s.addArgs(e.args),s):(console.error("Missing mandatory 'snapshot' argument at "+e.ts/1e3),s)}getSnapshot(){const e=this.args.snapshot;if(!e)throw new Error("ObjectSnapshot has no snapshot argument.");return e}}class I extends E{steps;causedFrame;constructor(e){super(e.categoriesString,e.name,e.phase,e.startTime,e.thread),this.addArgs(e.args),this.steps=[e],this.causedFrame=!1}addStep(e){this.steps.push(e),"F"!==e.phase&&"e"!==e.phase||(this.setEndTime(e.startTime),this.steps[0].setEndTime(e.startTime))}}class C{children;constructor(e){this.children=[e]}addChild(e){this.children.push(e)}}class b{model;idInternal;#A;#S;constructor(e,t){this.model=e,this.idInternal=t,this.#A="",this.#S=0}static sort(e){return e.sort(((e,t)=>e.#S!==t.#S?e.#S-t.#S:e.name().localeCompare(t.name())))}setName(e){this.#A=e}name(){return this.#A}id(){return this.idInternal}setSortIndex(e){this.#S=e}getModel(){return this.model}}class A extends b{threads;#w;constructor(e,t){super(e,t),this.threads=new Map,this.#w=new Map}threadById(e){let t=this.threads.get(e);return t||(t=new S(this,e),this.threads.set(e,t)),t}threadByName(e){return this.#w.get(e)||null}setThreadByName(e,t){this.#w.set(e,t)}addEvent(e){return this.threadById(e.tid).addEvent(e)}sortedThreads(){return b.sort([...this.threads.values()])}}class S extends b{#N;#P;#M;#x;constructor(e,t){super(e.getModel(),t),this.#N=e,this.#P=[],this.#M=[],this.#x=null}#R(e,t){return e.phase===t}tracingComplete(){this.#M.sort(g.compareStartTime),this.#P.sort(g.compareStartTime);const e=[],t=new Set;for(let s=0;s<this.#P.length;++s){const n=this.#P[s];if(n.ordinal=s,this.#R(n,"E")){if(t.add(s),!e.length)continue;const r=e.pop();if(!r)continue;r.name!==n.name||r.categoriesString!==n.categoriesString?console.error("B/E events mismatch at "+r.startTime+" ("+r.name+") vs. "+n.startTime+" ("+n.name+")"):r.complete(n)}else this.#R(n,"B")&&e.push(n)}for(;e.length;){const t=e.pop();t&&(t.phase="I")}this.#P=this.#P.filter(((e,s)=>!t.has(s)))}addEvent(e){const t="O"===e.ph?T.fromPayload(e,this):y.fromPayload(e,this);if(h.isTopLevelEvent(t)){const e=this.#x;if(e&&(e.endTime||0)>t.startTime)return null;this.#x=t}return this.#P.push(t),t}addAsyncEvent(e){this.#M.push(e)}setName(e){super.setName(e),this.#N.setThreadByName(e,this)}process(){return this.#N}events(){return this.#P}asyncEvents(){return this.#M}removeEventsByName(e){const t=[];return this.#P=this.#P.filter((s=>!!s&&(s.name!==e||(t.push(s),!1)))),t}}const w=new Map;function N(e,t){if(e instanceof g)return e.hasCategory(t);let s=w.get(e.cat);return s||(s=new Set(e.cat.split(",")||[])),s.has(t)}var P=Object.freeze({__proto__:null,TracingModel:h,eventPhasesOfInterestForTraceBounds:p,MetadataEvent:m,LegacyTopLevelEventCategory:u,DevToolsMetadataEventCategory:v,DevToolsTimelineEventCategory:f,eventHasPayload:function(e){return"rawPayload"in e},Event:g,ConstructedEvent:E,PayloadEvent:y,ObjectSnapshot:T,AsyncEvent:I,Process:A,Thread:S,timesForEventInMilliseconds:function(e){return e instanceof g?{startTime:s.Timing.MilliSeconds(e.startTime),endTime:e.endTime?s.Timing.MilliSeconds(e.endTime):void 0,duration:s.Timing.MilliSeconds(e.duration||0),selfTime:s.Timing.MilliSeconds(e.selfTime)}:t.Timing.eventTimingsMilliSeconds(e)},eventHasCategory:N,phaseForEvent:function(e){return e instanceof g?e.phase:e.ph},threadIDForEvent:function(e){return e instanceof g?e.thread.idInternal:e.tid},eventIsFromNewEngine:function(e){return null!==e&&!(e instanceof g)}});class M extends Event{data;static eventName="traceparseprogress";constructor(e,t={bubbles:!0}){super(M.eventName,t),this.data=e}}class x extends EventTarget{#B;#_="IDLE";#D=s.Configuration.DEFAULT;static createWithAllHandlers(){return new x(r.ModelHandlers,s.Configuration.DEFAULT)}constructor(e,t){super(),this.#O(e),this.#B={Meta:r.ModelHandlers.Meta,...e},t&&(this.#D=t),this.#F()}updateConfiguration(e){this.#D=e,this.#F()}#F(){for(const e of Object.values(this.#B))"handleUserConfig"in e&&e.handleUserConfig&&e.handleUserConfig(this.#D)}#O(e){if(Object.keys(e).length===Object.keys(r.ModelHandlers).length)return;const t=new Set;for(const[s,n]of Object.entries(e)){t.add(s);for(const e of n.deps?.()||[])t.add(e)}const s=new Set(Object.keys(e));t.delete("Meta");for(const e of t)if(!s.has(e))throw new Error(`Required handler ${e} not provided.`)}reset(){if("PARSING"===this.#_)throw new Error("Trace processor can't reset while parsing.");const e=Object.values(this.#B);for(const t of e)t.reset();this.#_="IDLE"}async parse(e,t=!1){if("IDLE"!==this.#_)throw new Error(`Trace processor can't start parsing when not idle. Current state: ${this.#_}`);try{this.#_="PARSING",await this.#L(e,t),this.#_="FINISHED_PARSING"}catch(e){throw this.#_="ERRORED_WHILE_PARSING",e}}async#L(e,t){const{pauseDuration:s,eventsPerChunk:n}=this.#D.processing,r=new B(e,s,n),a=[...R(this.#B).values()];for(const e of a)e.reset();for(const e of a)e.initialize?.(t);for await(const e of r)if(2!==e.kind)for(const t of a)t.handleEvent(e.data);else this.dispatchEvent(new M(e.data));for(const e of a)await(e.finalize?.())}get data(){if("FINISHED_PARSING"!==this.#_)return null;const e={};for(const[t,s]of Object.entries(this.#B))Object.assign(e,{[t]:s.data()});return e}}function R(e){const t=new Map,s=new Set,n=r=>{if(t.has(r))return;if(s.has(r)){let e="";for(const t of s)(e||t===r)&&(e+=`${t}->`);throw e+=r,new Error(`Found dependency cycle in trace event handlers: ${e}`)}s.add(r);const a=e[r];if(!a)return;const i=a.deps?.();i&&i.forEach(n),t.set(r,a)};for(const t of Object.keys(e))n(t);return t}class B{traceEvents;pauseDuration;eventsPerChunk;#k;constructor(e,t,s){this.traceEvents=e,this.pauseDuration=t,this.eventsPerChunk=s,this.#k=0}async*[Symbol.asyncIterator](){for(let e=0,t=this.traceEvents.length;e<t;e++)++this.#k%this.eventsPerChunk==0&&(yield{kind:2,data:{index:e,total:t}},await new Promise((e=>setTimeout(e,this.pauseDuration)))),yield{kind:1,data:this.traceEvents[e]}}}var _=Object.freeze({__proto__:null,TraceParseProgressEvent:M,TraceProcessor:x,sortHandlers:R});class D extends EventTarget{#U=[];#j=new Map;#H=[];#$=0;#z;#G=s.Configuration.DEFAULT;static createWithAllHandlers(e){return new D(r.ModelHandlers,e)}constructor(e,t){super(),t&&(this.#G=t),this.#z=new x(e,this.#G)}updateConfiguration(e){this.#G=e,this.#z.updateConfiguration(e)}async parse(e,t){const s=t?.metadata||{},n=t?.isFreshRecording||!1,r=e=>{const{data:t}=e;this.dispatchEvent(new O({type:"PROGRESS_UPDATE",data:t}))};this.#z.addEventListener(M.eventName,r);const a={traceEvents:e,metadata:s,traceParsedData:null};try{await this.#z.parse(e,n),this.#V(a,this.#z.data),this.#U.push(a)}catch(e){throw e}finally{this.#z.removeEventListener(M.eventName,r),this.dispatchEvent(new O({type:"COMPLETE",data:"done"}))}}#V(s,n){s.traceParsedData=n,this.#$++;let r=`Trace ${this.#$}`,a=null;if(s.traceParsedData&&(a=t.Trace.extractOriginFromTrace(s.traceParsedData.Meta.mainFrameURL),a)){const t=e.MapUtilities.getWithDefault(this.#j,a,(()=>1));r=`${a} (${t})`,this.#j.set(a,t+1)}this.#H.push(r)}traceParsedData(e=this.#U.length-1){return this.#U[e]?this.#U[e].traceParsedData:null}metadata(e){return this.#U[e]?this.#U[e].metadata:null}traceEvents(e){return this.#U[e]?this.#U[e].traceEvents:null}size(){return this.#U.length}deleteTraceByIndex(e){this.#U.splice(e,1),this.#H.splice(e,1)}getRecordingsAvailable(){return this.#H}resetProcessor(){this.#z.reset()}}class O extends Event{data;static eventName="modelupdate";constructor(e){super(O.eventName),this.data=e}}var F=Object.freeze({__proto__:null,Model:D,ModelUpdateEvent:O,isModelUpdateDataComplete:function(e){return"COMPLETE"===e.type},isModelUpdateDataProgress:function(e){return"PROGRESS_UPDATE"===e.type}});class L extends o.SDKModel.SDKModel{#W;#K;#q;#J;#X;constructor(e){super(e),this.#W=e.tracingAgent(),e.registerTracingDispatcher(new k(this)),this.#K=null,this.#q=0,this.#J=0}bufferUsage(e,t,s){this.#q=void 0===t?null:t,this.#K&&this.#K.tracingBufferUsage(e||s||0)}eventsCollected(e){this.#K&&(this.#K.traceEventsCollected(e),this.#J+=e.length,this.#q?(this.#J>this.#q&&(this.#J=this.#q),this.#K.eventsRetrievalProgress(this.#J/this.#q)):this.#K.eventsRetrievalProgress(0))}tracingComplete(){this.#q=0,this.#J=0,this.#K&&(this.#K.tracingComplete(),this.#K=null),this.#X=!1}async reset(){this.#K&&await this.#W.invoke_end(),this.#q=0,this.#J=0,this.#K=null,this.#X=!1}async start(e,t,s){if(this.#K)throw new Error("Tracing is already started");this.#K=e;const n={bufferUsageReportingInterval:500,categories:t,options:s,transferMode:"ReportEvents"},r=await this.#W.invoke_start(n);return r.getError()&&(this.#K=null),await this.warmupJsProfiler(),r}async warmupJsProfiler(){const e=this.target().model(o.RuntimeModel.RuntimeModel);e&&await e.checkSideEffectSupport()}stop(){if(!this.#K)throw new Error("Tracing is not started");if(this.#X)throw new Error("Tracing is already being stopped");this.#X=!0,this.#W.invoke_end()}}class k{#Q;constructor(e){this.#Q=e}bufferUsage({value:e,eventCount:t,percentFull:s}){this.#Q.bufferUsage(e,t,s)}dataCollected({value:e}){this.#Q.eventsCollected(e)}tracingComplete(){this.#Q.tracingComplete()}}o.SDKModel.SDKModel.register(L,{capabilities:o.Target.Capability.Tracing,autostart:!1});var U=Object.freeze({__proto__:null,TracingManager:L});export{d as EntriesFilter,P as Legacy,_ as Processor,F as TraceModel,U as TracingManager};
