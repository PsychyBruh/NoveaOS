import*as e from"../../core/common/common.js";import*as t from"../../core/host/host.js";import*as r from"../../core/i18n/i18n.js";import*as s from"../../core/sdk/sdk.js";import*as n from"../../models/bindings/bindings.js";import*as i from"../../ui/legacy/legacy.js";import*as o from"./components/components.js";import*as a from"../../ui/visual_logging/visual_logging.js";const d={noOpenInspections:"No open inspections"},c=r.i18n.registerUIStrings("panels/linear_memory_inspector/LinearMemoryInspectorPane.ts",d),l=r.i18n.getLocalizedString.bind(void 0,c);let h;class g extends(e.ObjectWrapper.eventMixin(i.Widget.VBox)){#e;constructor(){super(!1),this.element.setAttribute("jslog",`${a.panel().context("linear-memory-inspector")}`);const e=document.createElement("div");e.textContent=l(d.noOpenInspections),e.style.display="flex",this.#e=new i.TabbedPane.TabbedPane,this.#e.setPlaceholderElement(e),this.#e.setCloseableTabs(!0),this.#e.setAllowTabReorder(!0,!0),this.#e.addEventListener(i.TabbedPane.Events.TabClosed,this.#t,this),this.#e.show(this.contentElement)}static instance(){return h||(h=new g),h}#r(e){const t=this.#e.tabView(e);if(null===t)throw new Error(`No linear memory inspector view for the given tab id: ${e}`);return t}create(e,t,r,s){const n=new m(r,s,e);this.#e.appendTab(e,t,n,void 0,!1,!0),this.#e.selectTab(e)}close(e){this.#e.closeTab(e,!1)}reveal(e,t){const r=this.#r(e);void 0!==t&&r.updateAddress(t),this.refreshView(e),this.#e.selectTab(e)}refreshView(e){this.#r(e).refreshData()}#t(e){const{tabId:t}=e.data;this.dispatchEventToListeners("ViewClosed",t)}}class m extends i.Widget.VBox{#s;#n;#i;#o;firstTimeOpen;constructor(e,t=0,r){if(super(!1),t<0||t>=e.length())throw new Error("Requested address is out of bounds.");this.#s=e,this.#n=t,this.#i=r,this.#o=new o.LinearMemoryInspector.LinearMemoryInspector,this.#o.addEventListener(o.LinearMemoryInspector.MemoryRequestEvent.eventName,(e=>{this.#a(e)})),this.#o.addEventListener(o.LinearMemoryInspector.AddressChangedEvent.eventName,(e=>{this.updateAddress(e.data)})),this.#o.addEventListener(o.LinearMemoryInspector.SettingsChangedEvent.eventName,(e=>{e.stopPropagation(),this.saveSettings(e.data)})),this.#o.addEventListener(o.LinearMemoryHighlightChipList.DeleteMemoryHighlightEvent.eventName,(e=>{v.instance().removeHighlight(this.#i,e.data),this.refreshData()})),this.contentElement.appendChild(this.#o),this.firstTimeOpen=!0}wasShown(){this.refreshData()}saveSettings(e){v.instance().saveSettings(e)}updateAddress(e){if(e<0||e>=this.#s.length())throw new Error("Requested address is out of bounds.");this.#n=e}refreshData(){v.getMemoryForAddress(this.#s,this.#n).then((({memory:e,offset:t})=>{let r,s,n;if(this.firstTimeOpen){const e=v.instance().loadSettings();r=e.valueTypes,s=e.modes,n=e.endianness,this.firstTimeOpen=!1}this.#o.data={memory:e,address:this.#n,memoryOffset:t,outerMemoryLength:this.#s.length(),valueTypes:r,valueTypeModes:s,endianness:n,highlightInfo:this.#d()}}))}#a(e){const{start:t,end:r,address:s}=e.data;if(s<t||s>=r)throw new Error("Requested address is out of bounds.");v.getMemoryRange(this.#s,t,r).then((e=>{this.#o.data={memory:e,address:s,memoryOffset:t,outerMemoryLength:this.#s.length(),highlightInfo:this.#d()}}))}#d(){const e=v.instance().getHighlightInfo(this.#i);if(void 0!==e){if(e.startAddress<0||e.startAddress>=this.#s.length())throw new Error("HighlightInfo start address is out of bounds.");if(e.size<=0)throw new Error("Highlight size must be a positive number.")}return e}}var p=Object.freeze({__proto__:null,LinearMemoryInspectorPane:g});const u={couldNotOpenLinearMemory:"Could not open linear memory inspector: failed locating buffer.",revealInMemoryInspectorPanel:"Reveal in Memory inspector panel"},f=r.i18n.registerUIStrings("panels/linear_memory_inspector/LinearMemoryInspectorController.ts",u),b=r.i18n.getLocalizedString.bind(void 0,f),y=1e3;let M;class I{#c;constructor(e){this.#c=e}length(){return this.#c.byteLength()}async getRange(e,t){const r=Math.min(t,this.length());if(e<0||e>r)return console.error(`Requesting invalid range of memory: (${e}, ${t})`),new Uint8Array(0);const s=await this.#c.bytes(e,r);return new Uint8Array(s)}}class v extends s.TargetManager.SDKModelObserver{#l=g.instance();#h=new Map;#g=new Map;#m;constructor(){super(),s.TargetManager.TargetManager.instance().observeModels(s.RuntimeModel.RuntimeModel,this),s.TargetManager.TargetManager.instance().addModelListener(s.DebuggerModel.DebuggerModel,s.DebuggerModel.Events.GlobalObjectCleared,this.#p,this),this.#l.addEventListener("ViewClosed",this.#u.bind(this)),s.TargetManager.TargetManager.instance().addModelListener(s.DebuggerModel.DebuggerModel,s.DebuggerModel.Events.DebuggerPaused,this.#f,this);const t=o.ValueInterpreterDisplayUtils.getDefaultValueTypeMapping(),r={valueTypes:Array.from(t.keys()),valueTypeModes:Array.from(t),endianness:"Little Endian"};this.#m=e.Settings.Settings.instance().createSetting("lmiInterpreterSettings",r)}static instance(){return M||(M=new v,M)}static async getMemoryForAddress(e,t){const r=Math.max(0,t-500),s=r+y;return{memory:await e.getRange(r,s),offset:r}}static async getMemoryRange(e,t,r){if(t<0||t>r||t>=e.length())throw new Error("Requested range is out of bounds.");const s=Math.max(r,t+y);return await e.getRange(t,s)}async evaluateExpression(e,t){const r=await e.evaluate({expression:t});if("error"in r)console.error(`Tried to evaluate the expression '${t}' but got an error: ${r.error}`);else{if(!("exceptionDetails"in r)||!r?.exceptionDetails?.text)return r.object;console.error(`Tried to evaluate the expression '${t}' but got an exception: ${r.exceptionDetails.text}`)}}saveSettings(e){const t=Array.from(e.valueTypes),r=[...e.modes];this.#m.set({valueTypes:t,valueTypeModes:r,endianness:e.endianness})}loadSettings(){const e=this.#m.get();return{valueTypes:new Set(e.valueTypes),modes:new Map(e.valueTypeModes),endianness:e.endianness}}getHighlightInfo(e){return this.#g.get(e)}removeHighlight(e,t){this.getHighlightInfo(e)===t&&this.#g.delete(e)}setHighlightInfo(e,t){this.#g.set(e,t)}#b(e){this.#g.delete(e)}static async retrieveDWARFMemoryObjectAndAddress(t){if(!(t instanceof n.DebuggerLanguagePlugins.ExtensionRemoteObject))return;const r=t,s=t.linearMemoryAddress;if(void 0===s)return;const i=r.callFrame,o=await t.debuggerModel().agent.invoke_evaluateOnCallFrame({callFrameId:i.id,expression:"memories[0]"}),a=o.getError();a&&(console.error(a),e.Console.Console.instance().error(b(u.couldNotOpenLinearMemory)));return{obj:t.debuggerModel().runtimeModel().createRemoteObject(o.result),address:s}}static extractObjectSize(e){return e.linearMemorySize??0}static extractObjectTypeDescription(e){const t=e.description;if(!t)return"";const r=t.charAt(t.length-1),s=t.charAt(t.length-2);return"*"===r||"&"===r?" "===s?t.slice(0,t.length-2):t.slice(0,t.length-1):t}static extractObjectName(e,t){const r=e.description?.charAt(e.description.length-1);return"*"===r?"*"+t:t}async reveal({object:e,expression:r},n){const o=await v.retrieveDWARFMemoryObjectAndAddress(e);let a,d=e;void 0!==o&&(a=o.address,d=o.obj),void 0!==a?t.userMetrics.linearMemoryInspectorTarget(t.UserMetrics.LinearMemoryInspectorTarget.DWARFInspectableAddress):"arraybuffer"===d.subtype?t.userMetrics.linearMemoryInspectorTarget(t.UserMetrics.LinearMemoryInspectorTarget.ArrayBuffer):"dataview"===d.subtype?t.userMetrics.linearMemoryInspectorTarget(t.UserMetrics.LinearMemoryInspectorTarget.DataView):"typedarray"===d.subtype?t.userMetrics.linearMemoryInspectorTarget(t.UserMetrics.LinearMemoryInspectorTarget.TypedArray):(console.assert("webassemblymemory"===d.subtype),t.userMetrics.linearMemoryInspectorTarget(t.UserMetrics.LinearMemoryInspectorTarget.WebAssemblyMemory));const c=await async function(e){const t=await e.runtimeModel().agent.invoke_callFunctionOn({objectId:e.objectId,functionDeclaration:"function() { return this instanceof ArrayBuffer || (typeof SharedArrayBuffer !== 'undefined' && this instanceof SharedArrayBuffer) ? this : this.buffer; }",silent:!0,objectGroup:"linear-memory-inspector"}),r=t.getError();if(r)throw new Error(`Remote object representing ArrayBuffer could not be retrieved: ${r}`);return e=e.runtimeModel().createRemoteObject(t.result),new s.RemoteObject.RemoteArrayBuffer(e)}(d),{internalProperties:l}=await c.object().getOwnProperties(!1),h=l?.find((({name:e})=>"[[ArrayBufferData]]"===e)),g=h?.value?.value;if(!g)throw new Error("Unable to find backing store id for array buffer");const m=l?.find((({name:e})=>"[[WebAssemblyMemory]]"===e)),p=m?.value,u=v.extractHighlightInfo(e,r);if(u?this.setHighlightInfo(g,u):this.#b(g),this.#h.has(g))return this.#l.reveal(g,a),void i.ViewManager.ViewManager.instance().showView("linear-memory-inspector",n);const f=String(p?p.description:c.object().description);this.#h.set(g,c.object());const b=new I(c);this.#l.create(g,f,b,a),i.ViewManager.ViewManager.instance().showView("linear-memory-inspector",n)}appendApplicableItems(e,r,n){if(n.property.value?.isLinearMemoryInspectable()){const e=n.path(),i=n.property.value;r.debugSection().appendItem(b(u.revealInMemoryInspectorPanel),(()=>{t.userMetrics.linearMemoryInspectorRevealedFrom(t.UserMetrics.LinearMemoryInspectorRevealedFrom.ContextMenu),this.reveal(new s.RemoteObject.LinearMemoryInspectable(i,e))}))}}static extractHighlightInfo(e,t){if(!(e instanceof n.DebuggerLanguagePlugins.ExtensionRemoteObject))return;const r=e.linearMemoryAddress??0;let s;try{s={startAddress:r,size:v.extractObjectSize(e),name:t?v.extractObjectName(e,t):t,type:v.extractObjectTypeDescription(e)}}catch(e){s=void 0}return s}modelRemoved(e){for(const[t,r]of this.#h)e===r.runtimeModel()&&(this.#h.delete(t),this.#b(t),this.#l.close(t))}#f(e){const t=e.data;for(const[e,r]of this.#h)if(t.runtimeModel()===r.runtimeModel()){const r=t.debuggerPausedDetails()?.callFrames[0];r?this.updateHighlightedMemory(e,r).then((()=>this.#l.refreshView(e))):(this.#b(e),this.#l.refreshView(e))}}#p(e){this.modelRemoved(e.data.runtimeModel())}#u({data:e}){const t=this.#h.get(e);t&&t.release(),this.#h.delete(e),this.#b(e)}async updateHighlightedMemory(e,t){const r=this.getHighlightInfo(e),s=r?.name;if(!r||!s)return void this.#b(e);const n=await this.evaluateExpression(t,s);if(!n)return void this.#b(e);const i=v.extractHighlightInfo(n,s);i&&this.#y(i,r)?this.setHighlightInfo(e,i):this.#b(e)}#y(e,t){return e.type===t.type&&e.startAddress===t.startAddress}}var w=Object.freeze({__proto__:null,RemoteArrayBufferWrapper:I,isDWARFMemoryObject:function(e){return e instanceof n.DebuggerLanguagePlugins.ExtensionRemoteObject&&void 0!==e.linearMemoryAddress},LinearMemoryInspectorController:v});export{w as LinearMemoryInspectorController,p as LinearMemoryInspectorPane};
